{
  "name": "postcss",
  "version": "0.2.0",
  "description": "Framework for CSS postprocessors",
  "keywords": [
    "css",
    "parser",
    "postproccessor"
  ],
  "author": {
    "name": "Andrey Sitnik",
    "email": "andrey@sitnik.ru"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/ai/postcss.git"
  },
  "dependencies": {
    "source-map": "*"
  },
  "devDependencies": {
    "coffee-script": "1.6.3",
    "fs-extra": "0.8.1",
    "should": "2.1.1",
    "mocha": "1.15.1"
  },
  "main": "lib/postcss",
  "scripts": {
    "test": "mocha"
  },
  "readme": "# PostCSS\n\nPostCSS is a framework for CSS postprocessors,\nto modify CSS by your JS function.\n\nIt takes care of most common CSS tool tasks:\n\n1. parses CSS;\n2. gives you usable JS API to edit CSS node tree;\n3. saves modified node tree to new CSS;\n4. generates (or modifies existent) source map for your changes;\n\nYou can use this framework to write you own:\n\n* CSS minifier or beautifizer.\n* Grunt plugin to generate sprites, include `data-uri` images\n  or any other works.\n* Text editor plugin to automate CSS routine.\n* Command-line CSS tool.\n\nSponsored by [Evil Martians](http://evilmartians.com/).\n\n## Build with PostCSS\n\n* [Autoprefixer](https://github.com/ai/autoprefixer)\n* [grunt-pixrem](https://github.com/robwierzbowski/grunt-pixrem)\n\n## Quick Example\n\nLet’s fix forgotten `content` property in `::before` and `::after`:\n\n```js\nvar postcss = require('postcss');\n\nvar contenter = postcss(function (css) {\n    css.eachRule(function (rule) {\n        if ( rule.selector.match(/::(before|after)/) ) {\n            // In every ::before/::after rule\n\n            // Did we forget content property?\n            var good = rule.some(function (i) { return i.prop == 'content'; });\n\n            if ( !good ) {\n                // Add content: '' if we forget it\n                rule.prepend({ prop: 'content', value: '\"\"' });\n            }\n\n        }\n    });\n});\n```\n\nAnd then CSS with forgotten `content`:\n\n```css\na::before {\n    width: 10px;\n    height: 10px\n}\n```\n\nwill be fixed by our new `contenter`:\n\n```js\nvar fixed = contenter.process(css).css;\n```\n\nto:\n\n```css\na::before {\n    content: \"\";\n    width: 10px;\n    height: 10px\n}\n```\n\n## Features\n\n### Source Map\n\nPostCSS generates source map for its transformations:\n\n```js\nresult = processor.process(css, { map: true, from: 'from.css', to: 'to.css' });\nresult.css // String with processed CSS\nresult.map // Source map\n```\n\nAnd modifies source map from previous step (like Sass preprocessor):\n\n```js\nvar sassMap = fs.readFileSync('from.sass.map');\nprocessor.process(css, { map: sassMap, from: 'from.sass.css', to: 'to.css' });\n```\n\n### Preserves code formatting and indentations\n\nPostCSS will not change any byte of rule if you don't modify node:\n\n```js\npostcss(function (css) { }).process(css).css == css;\n```\n\nAnd when you modify CSS nodes, PostCSS will try to copy coding style:\n\n```js\ncontenter.process(\"a::before{color: black}\")\n// a::before{content: '';color: black}\n\ncontenter.process(\"a::before {\\n  color: black;\\n  }\")\n// a::before {\n//   content: '';\n//   color: black;\n//   }\n```\n\n## Why PostCSS Better Than …\n\n### Preprocessors\n\nPreprocessors (like Sass or Stylus) give us special language with variables,\nmixins, statements and compile it to CSS. Compass, nib and other mixins\nlibraries use this languages to work with prefixes, sprites and inline images.\n\nBut Sass and Stylus languages were created to be syntax-sugar for CSS.\nWriting really complicated programs using preporcessor languages is very difficult.\n[Autoprefixer] is absolutely impossible on Sass.\n\nPostCSS gives you comfort and power of JS or CoffeeScript to working with CSS.\nYou can do really magic things with wide range of [npm] libraries.\n\nBut postprocessors are not enemies for preprocessors. Sass and Stylus is still\nthe best way to improve readability and add some syntax sugar to CSS. You can easily combine preprocessors and postprocessors.\n\n[Autoprefixer]: https://github.com/ai/autoprefixer\n[npm]:          https://npmjs.org/\n\n### RegExp\n\nSome Grunt plugins modify CSS with regular expressions. But CSS parser and\nnode tree are much safer way to edit CSS. Also regexps will break source maps\ngenerated by preprocessors.\n\n### CSS Parsers\n\nThere are a lot of good CSS parsers, like [Gonzales]. But they help you only\nwith first step.\n\nUnlike them PostCSS gives you useful high level API (for example,\nsafe iterators) and changes source map generator (or modifier for existing\nsource map from preprocessors).\n\n[Gonzales]: https://github.com/css/gonzales\n\n### Rework\n\n[Rework] was a first CSS postprocessors framework. PostCSS is very similar\nto it.\n\nBut Rework has no high level API and rewrite your CSS code style\nand indentations. So it can’t be used in text editor plugins.\n\nUnlike it PostCSS preserves all spaces and code formatting.\nIf you don't change rule, output will be byte‑to‑byte equal.\n\n[Rework]: https://github.com/visionmedia/rework\n\n## Usage\n\n### Processor\n\nFunction `postcss(fn)` creates processor by your function:\n\n```js\nvar postcss = require('postcss');\n\nvar processor = postcss(function (css) {\n    // Code to modify CSS\n});\n```\n\nIf you want to combine multiple processors (and parse CSS only once),\nyou can create empty processor and add several functions by `use(fn)` method:\n\n```js\nvar all = postcss().\n          use(prefixer).\n          use(minifing);\n```\n\nProcessor function can just change current CSS node tree:\n\n```js\npostcss(function (css) {\n    css.append( /* new rule */ )\n});\n```\n\nor create totally new CSS root and return it:\n\n```js\npostcss(function (css) {\n    var newCSS = postcss.root()\n    // Add rules and declarations\n    return newCSS;\n});\n```\n\nProcessor will transform some CSS by `process(css, opts)` method:\n\n```js\nvar doubler = postcss(function (css) {\n    // Clone each declaration\n    css.eachDecl(function (decl) {\n        decl.parent.prepend( decl.clone() );\n    });\n});\n\nvar css    = \"a { color: black; }\";\nvar result = processor.process(css);\n\nresult.css //=> \"a { color: black; color: black; }\"\n```\n\nYou can set original CSS filename by `from` options and make syntax error\nmessages much more helpful:\n\n```js\nvar wrong = \"a {\";\nprocessor.process(wrong, { from: 'main.css' });\n//=> Can't parse CSS: Unclosed block at line 1:1 in main.css\n```\n### Source Map\n\nPostCSS will generate source map, if you set `map` option to `true`\nin `process(css, opts)` method.\n\nYou must set input and output CSS files paths (by `from` and `to` options)\nto generate correct map.\n\n```js\nvar result = processor.process(css, {\n    map:  true,\n    from: 'main.css',\n    to:   'main.out.css'\n});\n\nresult.map //=> '{\"version\":3,\"file\":\"main.out.css\",\"sources\":[\"main.css\"],\"names\":[],\"mappings\":\"AAAA,KAAI\"}'\n\nfs.writeFileSync('main.out.map', result.map);\n```\n\nPostCSS can also modify previous source map (for example, from Sass\ncompilation). So, if you compile: Sass to CSS and then minify CSS\nby postprocessor, final source map will contain mapping from Sass code\nto minified CSS.\n\nJust set original source map content (as string or JS object)\nto `map` option:\n\n```js\nvar result = minifier.process(css, {\n    map:   fs.readFileSync('main.sass.map'),\n    from: 'main.sass.css',\n    to:   'main.min.css'\n});\n\nresult.map //=> Source map from main.sass to main.min.css\n```\n\n### Nodes\n\nProcessor function will receive `Root` node with CSS node tree inside.\n\n```js\nvar processor = postcss(function (cssRoot) {\n});\n```\n\nThere are 3 types of child nodes: `AtRule`, `Rule` and `Declaration`.\nAll nodes contain `toString()` and `clone()` methods.\n\nYou can parse CSS and get `Root` node by `postcss.parse(css, opts)` method:\n\n```js\nvar postcss = require('postcss');\n\nvar cssRoot = postcss.parse('a { }');\n```\n\n### Node Source\n\nEvery node stores it origin file (if you set `from` option to `process`\nor `parse` method) and position at `source` property:\n\n```\nvar root = postcss.parse(css, { from: 'main.css' });\nvar rule = root.rules[1];\n\nrule.source.file  //=> 'main.css'\nrule.source.start //=> { line: 5,  position: 1 }\nrule.source.end   //=> { line: 10, position: 5 }\n```\n\n### Whitespaces\n\nAll nodes (exclude `Root`) have `before` property with all earlier spaces and comments.\n\nNodes with children (`Root`, `AtRule` and `Rule`) contain also `after` property\nwith spaces after last child and before `}` or end of file.\n\n```js\nvar root = postcss.parse(\"a {\\n  color: black;\\n}\\n\");\n\nroot.after                    //=> \"\\n\" from end of file\nroot.rules[0].after           //=> \"\\n\" before }\nroot.rules[0].decls[0].before //=> \"\\n  \" before color: black\n```\n\nSo, the simplest way to minify CSS is to clean `before` and `after` properties:\n\n```js\nvar minifier = postcss(function (css) {\n    css.eachDecl(function (decl) {\n        decl.before = '';\n    });\n    css.eachRule(function (rule) {\n        rule.before = '';\n        rule.after  = '';\n    });\n    css.eachAtRule(function (atRule) {\n        atRule.before = '';\n        atRule.after  = '';\n    });\n});\n\nvar css = \"a{\\n  color:black\\n}\\n\";\nminifier.process(css).css //=> \"a{color:black}\"\n```\n\n### Raw Properties\n\nSome CSS values (like selectors, at-rule params and declaration values) can\ncontain comments. PostCSS will clean them for you:\n\n```js\nvar root = postcss.parse(\"a /**/ b {}\");\nvar ab   = root.rules[0];\n\nab.selector //=> 'a  b' trimmed and cleaned from comments\n```\n\nBut PostCSS saves raw content to stringify it to CSS, if you don’t\nset new value. As you can remember, PostCSS tries to save origin CSS\nbyte-to-byte, when it’s possible:\n\n```js\nab.toString() //=> 'a /**/ b {}' with comment\n\nab.selector = '.link b';\nab.toString() //=> '.link b' you change value and magic was gone\n```\n\n### Containers\n\n`Root`, `AtRule` and `Rule` nodes can contain children in `rules` or `decls`\nproperty.\n\nThere are common method to work with children:\n\n* `append(newChild)` to add child at the end of children list.\n* `prepend(newChild)` to add child at the beginning of children list.\n* `insertBefore(existsChild, newChild)` to insert new child before some\n   existent children.\n* `insertAfter(existsChild, newChild)` to insert new child after some\n   existent children.\n* `remove(child)` to remove child.\n* `index(child)` to return child index.\n* `some(fn)` to return true if `fn` return true on any child.\n* `every(fn)` to return true if `fn` return true on all children.\n\nMethods `insertBefore`, `insertAfter` and `remove` can receive child node\nor child index number as existent child argument.\nHave in mind that `index` works much faster.\n\n### Children\n\n`AtRule`, `Rule` and `Declaration` nodes should be wrapped in other nodes.\n\nAll children contain `parent` property with parent node:\n\n```js\nrule.decls[0].parent == rule;\n```\n\nAll children has `removeSelf()` method:\n\n```js\nrule.decls[0].removeSelf();\n```\n\nBut `remove(index)` in parent with child index is much faster:\n\n```js\nrule.each(function (decl, i) {\n    rule.remove(i);\n});\n```\n\n### Iterators\n\nAll parent nodes have `each` method to iterate through children nodes:\n\n```js\nroot = postcss.parse('a { color: black; display: none }');\n\nroot.each(function (rule, i) {\n    console.log(rule.selector, i); // Will log \"a 0\"\n});\n\nroot.rules[0].each(function (decl, i) {\n    console.log(decl.prop, i); // Will log \"color 0\" and \"display 1\"\n});\n```\n\nInstead of simple `for` or `Array#forEach()` this iterator is safe.\nYou can change children inside iteration and it will fix current index:\n\n```js\nrule.rules.forEach(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will be infinity cycle, because on prepend current declaration become\n    // second and next index will go to current declaration again\n});\n\nrule.each(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will work correct (once clone each declaration), because after prepend\n    // iterator index will be recalculated\n});\n```\n\nBecause CSS is nested structure, PostCSS contains recursive iterator\nby node type:\n\n```js\nroot.eachDecl(function (decl, i) {\n    // Each declaration inside root\n});\n\nroot.eachRule(function (rule, i) {\n    // Each rule inside root and any nested at-rules\n});\n\nroot.eachAtRule(function (atRule, i) {\n    // Each at-rule inside root and any nested at-rules\n});\n```\n\n### Root Node\n\n`Root` node contains all CSS tree. Its children can be only `AtRule` or `Rule`\nnodes in `rules` property.\n\nYou can create new root by shortcut:\n\n```js\nvar root = postcss.root();\n```\n\nMethod `toString()` will stringify all current CSS:\n\n```js\nroot = postcss.parse(css);\nroot.toString() == css;\n```\n\n### AtRule Node\n\n```css\n@charset 'utf-8';\n\n@font-face {\n    font-family: 'Cool'\n}\n\n@media print {\n    img { display: none }\n}\n```\n\n`AtRule` has two own properties: `name` and `params`.\n\nAs you see, some at-rules don’t contain any children (like `@charset`\nor `@import`), some of at-rules can contain only declarations\n(like `@font-face` or `@page`), but most of them can contain rules\nand nested at-rules (like `@media`, `@keyframes` and others).\n\nParser select `AtRule` content type by its name. If you create `AtRule`\nnode manually, it will detect own content type with new child type on first\n`append` or other add method call:\n\n```js\nvar atRule = postcss.atRule({ name: '-x-animations' });\natRule.rules        //=> undefined\natRule.decls        //=> undefined\n\natRule.append( postcss.rule({ selector: 'from' }) );\natRule.rules.length //=> 1\natRule.decls        //=> undefined\n```\n\nYou can create new at-rule by shortcut:\n\n```js\nvar atRule = postcss.atRule({ name: 'charset', params: 'utf-8' });\n```\n\n### Rule Node\n\n```css\na {\n    color: black;\n}\n```\n\n`Rule` node has `selector` property and contains `Declaration` children\nin `decls` property.\n\nYou can miss `Declaration` constructor in `append` and other insert methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n\nProperty `semicolon` marks does last declaration in rule has semicolon or not:\n\n```js\nvar root = postcss.parse('a { color: black }');\nroot.rules[0].semicolon //=> false\n\nvar root = postcss.parse('a { color: black; }');\nroot.rules[0].semicolon //=> true\n```\n\nYou can create new rule by shortcut:\n\n```js\nvar rule = postcss.rule({ selector: 'a' });\n```\n\n### Declaration Node\n\n```css\ncolor: black\n```\n\n`Declaration` node has `prop` and `value` properties.\n\nYou can create new declaration by shortcut:\n\n```js\nvar decl = postcss.decl({ prop: 'color', value: 'black' });\n```\n\nOr use short form in `append()` and other add methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ai/postcss/issues"
  },
  "homepage": "https://github.com/ai/postcss",
  "_id": "postcss@0.2.0",
  "_from": "postcss@~0.2"
}
